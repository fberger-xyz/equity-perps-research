# Guardian Signatures in Unit

## Overview

Guardian signatures are a critical security mechanism for verifying the integrity of generated addresses in the Unit system. Before making any deposits or withdrawals, it is essential to verify these signatures to ensure the address has been correctly generated and approved by the Guardian Network.

## Why Signature Verification Matters

- **Security**: Ensures addresses are generated by legitimate Guardian nodes
- **Integrity**: Confirms address hasn't been tampered with
- **Trust**: Provides cryptographic proof of Guardian consensus
- **Protection**: Prevents man-in-the-middle attacks

> **Important**: Users are strongly encouraged to verify their addresses before making any deposit or withdrawal.

## Verification Requirements

### Minimum Threshold
- **Required Signatures**: At least 2 Guardian node signatures
- **Signature Algorithm**: ECDSA with SHA-256 hashing
- **Key Format**: 65-byte uncompressed public keys (0x04 prefix)

### Guardian Nodes

Each Guardian node has:
- **Node ID**: Unique identifier for the Guardian
- **Public Key**: 65-byte uncompressed ECDSA public key
- **Role**: Independent verification and signing

## Verification Process

The verification process involves these key steps:

1. **Retrieve Guardian public keys** for the network (mainnet/testnet)
2. **Generate the message payload** from proposal details
3. **Verify each signature** against its corresponding public key
4. **Ensure threshold is met** (minimum 2 valid signatures)

## Implementation Guide

### TypeScript/JavaScript Example

```typescript
const GUARDIAN_SIGNATURE_THRESHOLD = 2;

// Guardian node public keys (example)
const GUARDIAN_NODES = {
  mainnet: {
    'field-node': {
      publicKey: '0x04...' // 65-byte uncompressed key
    },
    'hl-node': {
      publicKey: '0x04...'
    },
    'node-1': {
      publicKey: '0x04...'
    }
  },
  testnet: {
    // Testnet guardian keys
  }
};

interface Proposal {
  src_chain: string;
  dst_chain: string;
  asset: string;
  dst_addr: string;
  generated_address: string;
}

interface VerificationResult {
  isValid: boolean;
  verifiedCount: number;
  details: Map<string, boolean>;
}

async function verifySignature(
  publicKey: string,
  message: string,
  signature: string
): Promise<boolean> {
  try {
    // Convert hex public key to CryptoKey
    const pubKeyBuffer = hexToBuffer(publicKey);
    const cryptoKey = await crypto.subtle.importKey(
      'raw',
      pubKeyBuffer,
      {
        name: 'ECDSA',
        namedCurve: 'P-256'
      },
      false,
      ['verify']
    );
    
    // Prepare message and signature
    const messageBuffer = new TextEncoder().encode(message);
    const signatureBuffer = hexToBuffer(signature);
    
    // Verify signature
    const isValid = await crypto.subtle.verify(
      {
        name: 'ECDSA',
        hash: 'SHA-256'
      },
      cryptoKey,
      signatureBuffer,
      messageBuffer
    );
    
    return isValid;
  } catch (error) {
    console.error('Signature verification failed:', error);
    return false;
  }
}

export async function verifyDepositAddressSignatures(
  signatures: { [nodeId: string]: string },
  proposal: Proposal,
  network: 'mainnet' | 'testnet' = 'mainnet'
): Promise<VerificationResult> {
  const guardianNodes = GUARDIAN_NODES[network];
  const verificationDetails = new Map<string, boolean>();
  let verifiedCount = 0;
  
  // Generate message payload
  const message = generateMessagePayload(proposal);
  
  // Verify each signature
  for (const [nodeId, signature] of Object.entries(signatures)) {
    const guardianNode = guardianNodes[nodeId];
    
    if (!guardianNode) {
      console.warn(`Unknown guardian node: ${nodeId}`);
      verificationDetails.set(nodeId, false);
      continue;
    }
    
    const isValid = await verifySignature(
      guardianNode.publicKey,
      message,
      signature
    );
    
    verificationDetails.set(nodeId, isValid);
    if (isValid) verifiedCount++;
  }
  
  return {
    isValid: verifiedCount >= GUARDIAN_SIGNATURE_THRESHOLD,
    verifiedCount,
    details: verificationDetails
  };
}

function generateMessagePayload(proposal: Proposal): string {
  // Format: "src_chain:dst_chain:asset:dst_addr:generated_address"
  return [
    proposal.src_chain,
    proposal.dst_chain,
    proposal.asset,
    proposal.dst_addr,
    proposal.generated_address
  ].join(':');
}

function hexToBuffer(hex: string): ArrayBuffer {
  // Remove 0x prefix if present
  const cleanHex = hex.startsWith('0x') ? hex.slice(2) : hex;
  const bytes = new Uint8Array(cleanHex.length / 2);
  
  for (let i = 0; i < bytes.length; i++) {
    bytes[i] = parseInt(cleanHex.substr(i * 2, 2), 16);
  }
  
  return bytes.buffer;
}
```

### Python Example

```python
import hashlib
from ecdsa import VerifyingKey, SECP256k1
from binascii import unhexlify

GUARDIAN_SIGNATURE_THRESHOLD = 2

def verify_guardian_signatures(signatures, proposal, network='mainnet'):
    """
    Verify Guardian signatures for a generated address
    
    Args:
        signatures: Dict of nodeId -> signature
        proposal: Dict with src_chain, dst_chain, asset, dst_addr, generated_address
        network: 'mainnet' or 'testnet'
    
    Returns:
        Tuple (is_valid, verified_count, details)
    """
    guardian_nodes = get_guardian_nodes(network)
    verified_count = 0
    details = {}
    
    # Generate message
    message = generate_message_payload(proposal)
    message_hash = hashlib.sha256(message.encode()).digest()
    
    for node_id, signature in signatures.items():
        if node_id not in guardian_nodes:
            details[node_id] = False
            continue
        
        try:
            # Get public key
            pub_key_hex = guardian_nodes[node_id]['publicKey']
            pub_key_bytes = unhexlify(pub_key_hex[2:])  # Remove 0x prefix
            
            # Create verifying key
            vk = VerifyingKey.from_string(pub_key_bytes, curve=SECP256k1)
            
            # Verify signature
            sig_bytes = unhexlify(signature[2:] if signature.startswith('0x') else signature)
            is_valid = vk.verify(sig_bytes, message_hash)
            
            details[node_id] = is_valid
            if is_valid:
                verified_count += 1
                
        except Exception as e:
            print(f"Failed to verify {node_id}: {e}")
            details[node_id] = False
    
    is_valid = verified_count >= GUARDIAN_SIGNATURE_THRESHOLD
    return is_valid, verified_count, details

def generate_message_payload(proposal):
    """Generate the message payload for signature verification"""
    return ':'.join([
        proposal['src_chain'],
        proposal['dst_chain'],
        proposal['asset'],
        proposal['dst_addr'],
        proposal['generated_address']
    ])
```

## Security Best Practices

### For Developers

1. **Always Verify**: Never skip signature verification
2. **Use HTTPS**: Only fetch Guardian keys over secure connections
3. **Cache Keys Carefully**: Guardian keys change rarely but verify updates
4. **Check Threshold**: Ensure minimum signatures are present
5. **Log Failures**: Record verification failures for audit

### For Users

1. **Verify Before Sending**: Always verify addresses before deposits
2. **Use Official Tools**: Use Unit's official verification tools
3. **Cross-Check**: Verify addresses through multiple channels if possible
4. **Report Issues**: Report any verification failures immediately

## Troubleshooting

### Common Issues

| Issue | Cause | Solution |
|-------|-------|----------|
| Signature count below threshold | Missing Guardian signatures | Request new address generation |
| Invalid signature format | Malformed signature data | Check signature encoding |
| Unknown Guardian node | Outdated Guardian list | Update Guardian node configuration |
| Verification always fails | Incorrect message format | Verify payload generation |

### Debugging Tips

1. **Log the message payload** being signed
2. **Verify public key format** (should be 65 bytes, 0x04 prefix)
3. **Check signature format** (DER encoded ECDSA)
4. **Test with known good signatures** from testnet

## Guardian Node Registry

### Fetching Current Guardians

```javascript
async function fetchGuardianNodes(network) {
  const response = await fetch(
    `https://api.hyperunit.xyz/guardians/${network}`
  );
  return response.json();
}
```

### Guardian Node Structure

```json
{
  "nodeId": "field-node",
  "publicKey": "0x04abc123...",
  "endpoint": "https://guardian1.hyperunit.xyz",
  "status": "active"
}
```

## Additional Resources

- [Generate Address API](/developers/api/generate-address)
- [Security Architecture](/architecture/security)
- [Guardian Network Components](/architecture/components)

## Support

For help with signature verification:
- Technical documentation: https://docs.hyperunit.xyz
- Developer support: developers@hyperunit.xyz
- Security concerns: security@hyperunit.xyz